#!/usr/bin/env python3
"""
Mock generator for CMock-compatible mock files.
This script generates mock files without requiring Ruby.
"""

import os
import re
import sys
from glob import glob
from dataclasses import dataclass
from typing import List, Tuple, Optional

@dataclass
class FunctionParam:
    type: str
    name: str
    is_pointer: bool = False
    is_const: bool = False

@dataclass
class Function:
    return_type: str
    name: str
    params: List[FunctionParam]
    is_variadic: bool = False

def parse_header(header_path: str) -> Tuple[str, List[Function]]:
    """Parse a C header file and extract function declarations."""
    with open(header_path, 'r') as f:
        content = f.read()

    # Get the module name from header filename
    basename = os.path.basename(header_path)
    module_name = basename.replace('.h', '')

    # Remove comments
    content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
    content = re.sub(r'//.*?$', '', content, flags=re.MULTILINE)

    # Remove preprocessor directives (but keep content for parsing)
    content_no_pp = re.sub(r'#.*?$', '', content, flags=re.MULTILINE)

    functions = []

    # Match function declarations - handle multi-line declarations
    # Pattern: return_type function_name(params);
    func_pattern = r'(?:extern\s+)?(\w+(?:\s*\*)?)\s+(\w+)\s*\(([^)]*)\)\s*;'

    for match in re.finditer(func_pattern, content_no_pp):
        return_type = match.group(1).strip()
        func_name = match.group(2).strip()
        params_str = match.group(3).strip()

        # Skip macros and typedefs
        if func_name.startswith('_') and func_name.endswith('_'):
            continue
        if return_type in ['typedef', 'struct', 'enum', 'union']:
            continue

        # Parse parameters
        params = []
        is_variadic = False

        if params_str and params_str != 'void':
            param_list = params_str.split(',')
            for param in param_list:
                param = param.strip()
                if param == '...':
                    is_variadic = True
                    continue
                if not param:
                    continue

                # Parse parameter type and name
                is_const = 'const' in param
                param = param.replace('const ', '').strip()

                # Handle pointers
                is_pointer = '*' in param
                param = param.replace('*', ' * ')
                parts = param.split()

                if len(parts) >= 2:
                    param_name = parts[-1]
                    param_type = ' '.join(parts[:-1]).replace(' * ', '*')
                    if is_const:
                        param_type = 'const ' + param_type
                    params.append(FunctionParam(
                        type=param_type,
                        name=param_name,
                        is_pointer=is_pointer,
                        is_const=is_const
                    ))
                elif len(parts) == 1:
                    # Just a type, no name
                    params.append(FunctionParam(
                        type=parts[0],
                        name=f'arg{len(params)}',
                        is_pointer=is_pointer,
                        is_const=is_const
                    ))

        functions.append(Function(
            return_type=return_type,
            name=func_name,
            params=params,
            is_variadic=is_variadic
        ))

    return module_name, functions

def generate_mock_header(module_name: str, header_file: str, functions: List[Function]) -> str:
    """Generate mock header file content."""
    guard = f'_MOCK{module_name.upper()}_H'
    mock_name = f'Mock{module_name}'

    lines = [
        '/* AUTOGENERATED FILE. DO NOT EDIT. */',
        f'#ifndef {guard}',
        f'#define {guard}',
        '',
        '#include "unity.h"',
        f'#include "{os.path.basename(header_file)}"',
        '',
        '/* Ignore the following warnings, since we are copying code */',
        '#if defined(__GNUC__) && !defined(__ICC) && !defined(__TMS470__)',
        '#pragma GCC diagnostic push',
        '#if !defined(__clang__)',
        '#pragma GCC diagnostic ignored "-Wpragmas"',
        '#endif',
        '#pragma GCC diagnostic ignored "-Wunknown-pragmas"',
        '#pragma GCC diagnostic ignored "-Wduplicate-decl-specifier"',
        '#endif',
        '',
        f'void {mock_name}_Init(void);',
        f'void {mock_name}_Destroy(void);',
        f'void {mock_name}_Verify(void);',
        '',
    ]

    for func in functions:
        lines.append(f'#define {func.name}_Ignore() {func.name}_CMockIgnore()')
        lines.append(f'void {func.name}_CMockIgnore(void);')
        lines.append(f'#define {func.name}_StopIgnore() {func.name}_CMockStopIgnore()')
        lines.append(f'void {func.name}_CMockStopIgnore(void);')

        if func.return_type != 'void':
            lines.append(f'#define {func.name}_IgnoreAndReturn(cmock_retval) {func.name}_CMockIgnoreAndReturn(__LINE__, cmock_retval)')
            lines.append(f'void {func.name}_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, {func.return_type} cmock_to_return);')

        # Callback typedef
        param_types = ', '.join([f'{p.type} {p.name}' for p in func.params] + ['int cmock_num_calls'])
        if not func.params:
            param_types = 'int cmock_num_calls'
        lines.append(f'typedef {func.return_type} (* CMOCK_{func.name}_CALLBACK)({param_types});')
        lines.append(f'void {func.name}_AddCallback(CMOCK_{func.name}_CALLBACK Callback);')
        lines.append(f'void {func.name}_Stub(CMOCK_{func.name}_CALLBACK Callback);')
        lines.append(f'#define {func.name}_StubWithCallback {func.name}_Stub')
        lines.append('')

    lines.extend([
        '#if defined(__GNUC__) && !defined(__ICC) && !defined(__TMS470__)',
        '#pragma GCC diagnostic pop',
        '#endif',
        '',
        '#endif',
    ])

    return '\n'.join(lines)

def generate_mock_source(module_name: str, header_file: str, functions: List[Function]) -> str:
    """Generate mock source file content."""
    mock_name = f'Mock{module_name}'

    lines = [
        '/* AUTOGENERATED FILE. DO NOT EDIT. */',
        '#include <string.h>',
        '#include <stdlib.h>',
        '#include <setjmp.h>',
        '#include "cmock.h"',
        f'#include "{mock_name}.h"',
        '',
    ]

    # String constants
    for func in functions:
        lines.append(f'static const char* CMockString_{func.name} = "{func.name}";')
    lines.append('')

    # Call instance structs
    for func in functions:
        lines.append(f'typedef struct _CMOCK_{func.name}_CALL_INSTANCE')
        lines.append('{')
        lines.append('  UNITY_LINE_TYPE LineNumber;')
        lines.append('  char IgnoreMode;')
        if func.return_type != 'void':
            lines.append(f'  {func.return_type} ReturnVal;')
        lines.append(f'}} CMOCK_{func.name}_CALL_INSTANCE;')
        lines.append('')

    # Mock instance struct
    lines.append(f'static struct {mock_name}Instance')
    lines.append('{')
    for func in functions:
        lines.append(f'  char {func.name}_IgnoreBool;')
        if func.return_type != 'void':
            lines.append(f'  {func.return_type} {func.name}_FinalReturn;')
        lines.append(f'  CMOCK_{func.name}_CALLBACK {func.name}_CallbackFunctionPointer;')
        lines.append(f'  int {func.name}_CallbackCalls;')
        lines.append(f'  CMOCK_MEM_INDEX_TYPE {func.name}_CallInstance;')
    lines.append('} Mock;')
    lines.append('')
    lines.append('extern jmp_buf AbortFrame;')
    lines.append('')

    # Verify function
    lines.append(f'void {mock_name}_Verify(void)')
    lines.append('{')
    lines.append('  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;')
    lines.append('  CMOCK_MEM_INDEX_TYPE call_instance;')
    for func in functions:
        lines.append(f'  call_instance = Mock.{func.name}_CallInstance;')
        lines.append(f'  if (Mock.{func.name}_IgnoreBool)')
        lines.append('    call_instance = CMOCK_GUTS_NONE;')
        lines.append('  if (CMOCK_GUTS_NONE != call_instance)')
        lines.append('  {')
        lines.append(f'    UNITY_SET_DETAIL(CMockString_{func.name});')
        lines.append('    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);')
        lines.append('  }')
        lines.append(f'  if (Mock.{func.name}_CallbackFunctionPointer != NULL)')
        lines.append('  {')
        lines.append('    call_instance = CMOCK_GUTS_NONE;')
        lines.append('    (void)call_instance;')
        lines.append('  }')
    lines.append('}')
    lines.append('')

    # Init function
    lines.append(f'void {mock_name}_Init(void)')
    lines.append('{')
    lines.append(f'  {mock_name}_Destroy();')
    lines.append('}')
    lines.append('')

    # Destroy function
    lines.append(f'void {mock_name}_Destroy(void)')
    lines.append('{')
    lines.append('  CMock_Guts_MemFreeAll();')
    lines.append('  memset(&Mock, 0, sizeof(Mock));')
    lines.append('}')
    lines.append('')

    # Generate each function mock
    for func in functions:
        # The actual mock function
        params_with_types = ', '.join([f'{p.type} {p.name}' for p in func.params])
        if func.is_variadic:
            params_with_types += ', ...' if params_with_types else '...'
        if not params_with_types:
            params_with_types = 'void'

        lines.append(f'{func.return_type} {func.name}({params_with_types})')
        lines.append('{')
        lines.append('  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;')
        lines.append(f'  CMOCK_{func.name}_CALL_INSTANCE* cmock_call_instance;')
        lines.append(f'  UNITY_SET_DETAIL(CMockString_{func.name});')
        lines.append(f'  cmock_call_instance = (CMOCK_{func.name}_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.{func.name}_CallInstance);')
        lines.append(f'  Mock.{func.name}_CallInstance = CMock_Guts_MemNext(Mock.{func.name}_CallInstance);')
        lines.append(f'  if (Mock.{func.name}_IgnoreBool)')
        lines.append('  {')
        lines.append('    UNITY_CLR_DETAILS();')
        if func.return_type != 'void':
            lines.append(f'    if (cmock_call_instance == NULL)')
            lines.append(f'      return Mock.{func.name}_FinalReturn;')
            lines.append('    return cmock_call_instance->ReturnVal;')
        else:
            lines.append('    return;')
        lines.append('  }')
        lines.append(f'  if (Mock.{func.name}_CallbackFunctionPointer != NULL)')
        lines.append('  {')
        callback_args = ', '.join([p.name for p in func.params] + [f'Mock.{func.name}_CallbackCalls++'])
        if not func.params:
            callback_args = f'Mock.{func.name}_CallbackCalls++'
        if func.return_type != 'void':
            lines.append(f'    {func.return_type} cmock_cb_ret = Mock.{func.name}_CallbackFunctionPointer({callback_args});')
            lines.append('    UNITY_CLR_DETAILS();')
            lines.append('    return cmock_cb_ret;')
        else:
            lines.append(f'    Mock.{func.name}_CallbackFunctionPointer({callback_args});')
            lines.append('    UNITY_CLR_DETAILS();')
            lines.append('    return;')
        lines.append('  }')
        lines.append('  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);')
        lines.append('  cmock_line = cmock_call_instance->LineNumber;')
        lines.append('  if (cmock_call_instance->IgnoreMode)')
        lines.append('  {')
        lines.append('    UNITY_CLR_DETAILS();')
        if func.return_type != 'void':
            lines.append('    return cmock_call_instance->ReturnVal;')
        else:
            lines.append('    return;')
        lines.append('  }')
        lines.append('  UNITY_CLR_DETAILS();')
        if func.return_type != 'void':
            lines.append('  return cmock_call_instance->ReturnVal;')
        lines.append('}')
        lines.append('')

        # Ignore function
        lines.append(f'void {func.name}_CMockIgnore(void)')
        lines.append('{')
        lines.append(f'  Mock.{func.name}_IgnoreBool = (char)1;')
        lines.append('}')
        lines.append('')

        # StopIgnore function
        lines.append(f'void {func.name}_CMockStopIgnore(void)')
        lines.append('{')
        lines.append(f'  Mock.{func.name}_IgnoreBool = (char)0;')
        lines.append('}')
        lines.append('')

        # IgnoreAndReturn function (if applicable)
        if func.return_type != 'void':
            lines.append(f'void {func.name}_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, {func.return_type} cmock_to_return)')
            lines.append('{')
            lines.append(f'  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_{func.name}_CALL_INSTANCE));')
            lines.append(f'  CMOCK_{func.name}_CALL_INSTANCE* cmock_call_instance = (CMOCK_{func.name}_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);')
            lines.append('  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);')
            lines.append('  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));')
            lines.append(f'  Mock.{func.name}_CallInstance = CMock_Guts_MemChain(Mock.{func.name}_CallInstance, cmock_guts_index);')
            lines.append(f'  Mock.{func.name}_IgnoreBool = (char)0;')
            lines.append('  cmock_call_instance->LineNumber = cmock_line;')
            lines.append('  cmock_call_instance->IgnoreMode = 1;')
            lines.append('  cmock_call_instance->ReturnVal = cmock_to_return;')
            lines.append(f'  Mock.{func.name}_FinalReturn = cmock_to_return;')
            lines.append('}')
            lines.append('')

        # Callback functions
        lines.append(f'void {func.name}_AddCallback(CMOCK_{func.name}_CALLBACK Callback)')
        lines.append('{')
        lines.append(f'  Mock.{func.name}_IgnoreBool = (char)0;')
        lines.append(f'  Mock.{func.name}_CallbackFunctionPointer = Callback;')
        lines.append('}')
        lines.append('')

        lines.append(f'void {func.name}_Stub(CMOCK_{func.name}_CALLBACK Callback)')
        lines.append('{')
        lines.append(f'  Mock.{func.name}_IgnoreBool = (char)0;')
        lines.append(f'  Mock.{func.name}_CallbackFunctionPointer = Callback;')
        lines.append('}')
        lines.append('')

    return '\n'.join(lines)

def generate_mocks(header_path: str, output_dir: str):
    """Generate mock files for a header."""
    module_name, functions = parse_header(header_path)

    if not functions:
        print(f"  Warning: No functions found in {header_path}")
        return False

    print(f"  Found {len(functions)} functions in {module_name}.h")

    mock_h = generate_mock_header(module_name, header_path, functions)
    mock_c = generate_mock_source(module_name, header_path, functions)

    mock_h_path = os.path.join(output_dir, f'Mock{module_name}.h')
    mock_c_path = os.path.join(output_dir, f'Mock{module_name}.c')

    with open(mock_h_path, 'w') as f:
        f.write(mock_h)

    with open(mock_c_path, 'w') as f:
        f.write(mock_c)

    print(f"  Generated Mock{module_name}.h and Mock{module_name}.c")
    return True

def main():
    # Headers to mock
    headers = [
        '../lib/debug.h',
        '../lib/mchar.h',
        '../lib/socklib.h',
        '../lib/filelib.h',
        '../lib/parse.h',
        '../lib/prefs.h',
        '../lib/external.h',
        '../lib/relaylib.h',
        '../lib/threadlib.h',
        '../lib/errors.h',
        '../lib/cbuf2.h',
        '../lib/https.h',
        '../lib/charset.h',
        '../lib/utf8.h',
        '../lib/findsep.h',
    ]

    script_dir = os.path.dirname(os.path.abspath(__file__))
    output_dir = os.path.join(script_dir, 'mocks')

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Remove old mocks
    for f in glob(os.path.join(output_dir, '*.*')):
        os.unlink(f)

    print("Generating mocks...")
    success_count = 0
    for header in headers:
        header_path = os.path.join(script_dir, header)
        if os.path.exists(header_path):
            if generate_mocks(header_path, output_dir):
                success_count += 1
        else:
            print(f"  Warning: {header_path} not found")

    print(f"\nGenerated {success_count} mock file pairs in {output_dir}")

if __name__ == '__main__':
    main()
