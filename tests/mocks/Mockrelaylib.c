/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mockrelaylib.h"

typedef struct _CMOCK_relaylib_set_response_header_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  error_code ReturnVal;
  char* Expected_http_header;

} CMOCK_relaylib_set_response_header_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  error_code ReturnVal;
  RIP_MANAGER_INFO* Expected_rmi;
  BOOL Expected_search_ports;
  u_short Expected_relay_port;
  u_short Expected_max_port;
  u_short* Expected_port_used;
  char* Expected_if_name;
  int Expected_max_connections;
  char* Expected_relay_ip;
  int Expected_have_metadata;

} CMOCK_relaylib_start_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_send_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  error_code ReturnVal;
  char* Expected_data;
  int Expected_len;
  int Expected_accept_new;
  int Expected_is_meta;

} CMOCK_relaylib_send_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_stop_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RIP_MANAGER_INFO* Expected_rmi;

} CMOCK_relaylib_stop_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_isrunning_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BOOL ReturnVal;

} CMOCK_relaylib_isrunning_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_send_meta_data_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  error_code ReturnVal;
  char* Expected_track;

} CMOCK_relaylib_send_meta_data_CALL_INSTANCE;

typedef struct _CMOCK_relaylib_disconnect_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  RIP_MANAGER_INFO* Expected_rmi;
  RELAY_LIST* Expected_prev;
  RELAY_LIST* Expected_ptr;

} CMOCK_relaylib_disconnect_CALL_INSTANCE;

static struct MockrelaylibInstance
{
  int relaylib_set_response_header_IgnoreBool;
  error_code relaylib_set_response_header_FinalReturn;
  CMOCK_relaylib_set_response_header_CALLBACK relaylib_set_response_header_CallbackFunctionPointer;
  int relaylib_set_response_header_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_set_response_header_CallInstance;
  int relaylib_start_IgnoreBool;
  error_code relaylib_start_FinalReturn;
  CMOCK_relaylib_start_CALLBACK relaylib_start_CallbackFunctionPointer;
  int relaylib_start_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_start_CallInstance;
  int relaylib_send_IgnoreBool;
  error_code relaylib_send_FinalReturn;
  CMOCK_relaylib_send_CALLBACK relaylib_send_CallbackFunctionPointer;
  int relaylib_send_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_send_CallInstance;
  int relaylib_stop_IgnoreBool;
  CMOCK_relaylib_stop_CALLBACK relaylib_stop_CallbackFunctionPointer;
  int relaylib_stop_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_stop_CallInstance;
  int relaylib_isrunning_IgnoreBool;
  BOOL relaylib_isrunning_FinalReturn;
  CMOCK_relaylib_isrunning_CALLBACK relaylib_isrunning_CallbackFunctionPointer;
  int relaylib_isrunning_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_isrunning_CallInstance;
  int relaylib_send_meta_data_IgnoreBool;
  error_code relaylib_send_meta_data_FinalReturn;
  CMOCK_relaylib_send_meta_data_CALLBACK relaylib_send_meta_data_CallbackFunctionPointer;
  int relaylib_send_meta_data_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_send_meta_data_CallInstance;
  int relaylib_disconnect_IgnoreBool;
  CMOCK_relaylib_disconnect_CALLBACK relaylib_disconnect_CallbackFunctionPointer;
  int relaylib_disconnect_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE relaylib_disconnect_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockrelaylib_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.relaylib_set_response_header_IgnoreBool)
    Mock.relaylib_set_response_header_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_set_response_header_CallInstance, cmock_line, "Function 'relaylib_set_response_header' called less times than expected.");
  if (Mock.relaylib_set_response_header_CallbackFunctionPointer != NULL)
    Mock.relaylib_set_response_header_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_start_IgnoreBool)
    Mock.relaylib_start_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_start_CallInstance, cmock_line, "Function 'relaylib_start' called less times than expected.");
  if (Mock.relaylib_start_CallbackFunctionPointer != NULL)
    Mock.relaylib_start_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_send_IgnoreBool)
    Mock.relaylib_send_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_send_CallInstance, cmock_line, "Function 'relaylib_send' called less times than expected.");
  if (Mock.relaylib_send_CallbackFunctionPointer != NULL)
    Mock.relaylib_send_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_stop_IgnoreBool)
    Mock.relaylib_stop_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_stop_CallInstance, cmock_line, "Function 'relaylib_stop' called less times than expected.");
  if (Mock.relaylib_stop_CallbackFunctionPointer != NULL)
    Mock.relaylib_stop_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_isrunning_IgnoreBool)
    Mock.relaylib_isrunning_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_isrunning_CallInstance, cmock_line, "Function 'relaylib_isrunning' called less times than expected.");
  if (Mock.relaylib_isrunning_CallbackFunctionPointer != NULL)
    Mock.relaylib_isrunning_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_send_meta_data_IgnoreBool)
    Mock.relaylib_send_meta_data_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_send_meta_data_CallInstance, cmock_line, "Function 'relaylib_send_meta_data' called less times than expected.");
  if (Mock.relaylib_send_meta_data_CallbackFunctionPointer != NULL)
    Mock.relaylib_send_meta_data_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.relaylib_disconnect_IgnoreBool)
    Mock.relaylib_disconnect_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.relaylib_disconnect_CallInstance, cmock_line, "Function 'relaylib_disconnect' called less times than expected.");
  if (Mock.relaylib_disconnect_CallbackFunctionPointer != NULL)
    Mock.relaylib_disconnect_CallInstance = CMOCK_GUTS_NONE;
}

void Mockrelaylib_Init(void)
{
  Mockrelaylib_Destroy();
}

void Mockrelaylib_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.relaylib_set_response_header_CallbackFunctionPointer = NULL;
  Mock.relaylib_set_response_header_CallbackCalls = 0;
  Mock.relaylib_start_CallbackFunctionPointer = NULL;
  Mock.relaylib_start_CallbackCalls = 0;
  Mock.relaylib_send_CallbackFunctionPointer = NULL;
  Mock.relaylib_send_CallbackCalls = 0;
  Mock.relaylib_stop_CallbackFunctionPointer = NULL;
  Mock.relaylib_stop_CallbackCalls = 0;
  Mock.relaylib_isrunning_CallbackFunctionPointer = NULL;
  Mock.relaylib_isrunning_CallbackCalls = 0;
  Mock.relaylib_send_meta_data_CallbackFunctionPointer = NULL;
  Mock.relaylib_send_meta_data_CallbackCalls = 0;
  Mock.relaylib_disconnect_CallbackFunctionPointer = NULL;
  Mock.relaylib_disconnect_CallbackCalls = 0;
}

error_code relaylib_set_response_header(char* http_header)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_set_response_header_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_set_response_header_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_set_response_header_CallInstance);
  Mock.relaylib_set_response_header_CallInstance = CMock_Guts_MemNext(Mock.relaylib_set_response_header_CallInstance);
  if (Mock.relaylib_set_response_header_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.relaylib_set_response_header_FinalReturn;
    memcpy(&Mock.relaylib_set_response_header_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(error_code));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.relaylib_set_response_header_CallbackFunctionPointer != NULL)
  {
    return Mock.relaylib_set_response_header_CallbackFunctionPointer(http_header, Mock.relaylib_set_response_header_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_set_response_header' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_http_header, http_header, cmock_line, "Function 'relaylib_set_response_header' called with unexpected value for argument 'http_header'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_relaylib_set_response_header(CMOCK_relaylib_set_response_header_CALL_INSTANCE* cmock_call_instance, char* http_header)
{
  cmock_call_instance->Expected_http_header = http_header;
}

void relaylib_set_response_header_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_set_response_header_CALL_INSTANCE));
  CMOCK_relaylib_set_response_header_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_set_response_header_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_set_response_header_CallInstance = CMock_Guts_MemChain(Mock.relaylib_set_response_header_CallInstance, cmock_guts_index);
  Mock.relaylib_set_response_header_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.relaylib_set_response_header_IgnoreBool = (int)1;
}

void relaylib_set_response_header_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* http_header, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_set_response_header_CALL_INSTANCE));
  CMOCK_relaylib_set_response_header_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_set_response_header_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_set_response_header_CallInstance = CMock_Guts_MemChain(Mock.relaylib_set_response_header_CallInstance, cmock_guts_index);
  Mock.relaylib_set_response_header_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_set_response_header(cmock_call_instance, http_header);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(error_code));
}

void relaylib_set_response_header_StubWithCallback(CMOCK_relaylib_set_response_header_CALLBACK Callback)
{
  Mock.relaylib_set_response_header_CallbackFunctionPointer = Callback;
}

error_code relaylib_start(RIP_MANAGER_INFO* rmi, BOOL search_ports, u_short relay_port, u_short max_port, u_short* port_used, char* if_name, int max_connections, char* relay_ip, int have_metadata)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_start_CallInstance);
  Mock.relaylib_start_CallInstance = CMock_Guts_MemNext(Mock.relaylib_start_CallInstance);
  if (Mock.relaylib_start_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.relaylib_start_FinalReturn;
    memcpy(&Mock.relaylib_start_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(error_code));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.relaylib_start_CallbackFunctionPointer != NULL)
  {
    return Mock.relaylib_start_CallbackFunctionPointer(rmi, search_ports, relay_port, max_port, port_used, if_name, max_connections, relay_ip, have_metadata, Mock.relaylib_start_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_start' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'rmi'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_search_ports, search_ports, cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'search_ports'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_relay_port), (void*)(&relay_port), sizeof(u_short), cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'relay_port'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_max_port), (void*)(&max_port), sizeof(u_short), cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'max_port'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_port_used), (void*)(port_used), sizeof(u_short), cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'port_used'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_if_name, if_name, cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'if_name'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_max_connections, max_connections, cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'max_connections'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_relay_ip, relay_ip, cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'relay_ip'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_have_metadata, have_metadata, cmock_line, "Function 'relaylib_start' called with unexpected value for argument 'have_metadata'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_relaylib_start(CMOCK_relaylib_start_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi, BOOL search_ports, u_short relay_port, u_short max_port, u_short* port_used, char* if_name, int max_connections, char* relay_ip, int have_metadata)
{
  cmock_call_instance->Expected_rmi = rmi;
  cmock_call_instance->Expected_search_ports = search_ports;
  memcpy(&cmock_call_instance->Expected_relay_port, &relay_port, sizeof(u_short));
  memcpy(&cmock_call_instance->Expected_max_port, &max_port, sizeof(u_short));
  cmock_call_instance->Expected_port_used = port_used;
  cmock_call_instance->Expected_if_name = if_name;
  cmock_call_instance->Expected_max_connections = max_connections;
  cmock_call_instance->Expected_relay_ip = relay_ip;
  cmock_call_instance->Expected_have_metadata = have_metadata;
}

void relaylib_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_start_CALL_INSTANCE));
  CMOCK_relaylib_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_start_CallInstance = CMock_Guts_MemChain(Mock.relaylib_start_CallInstance, cmock_guts_index);
  Mock.relaylib_start_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.relaylib_start_IgnoreBool = (int)1;
}

void relaylib_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi, BOOL search_ports, u_short relay_port, u_short max_port, u_short* port_used, char* if_name, int max_connections, char* relay_ip, int have_metadata, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_start_CALL_INSTANCE));
  CMOCK_relaylib_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_start_CallInstance = CMock_Guts_MemChain(Mock.relaylib_start_CallInstance, cmock_guts_index);
  Mock.relaylib_start_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_start(cmock_call_instance, rmi, search_ports, relay_port, max_port, port_used, if_name, max_connections, relay_ip, have_metadata);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(error_code));
}

void relaylib_start_StubWithCallback(CMOCK_relaylib_start_CALLBACK Callback)
{
  Mock.relaylib_start_CallbackFunctionPointer = Callback;
}

error_code relaylib_send(char* data, int len, int accept_new, int is_meta)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_send_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_send_CallInstance);
  Mock.relaylib_send_CallInstance = CMock_Guts_MemNext(Mock.relaylib_send_CallInstance);
  if (Mock.relaylib_send_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.relaylib_send_FinalReturn;
    memcpy(&Mock.relaylib_send_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(error_code));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.relaylib_send_CallbackFunctionPointer != NULL)
  {
    return Mock.relaylib_send_CallbackFunctionPointer(data, len, accept_new, is_meta, Mock.relaylib_send_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_send' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_data, data, cmock_line, "Function 'relaylib_send' called with unexpected value for argument 'data'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_len, len, cmock_line, "Function 'relaylib_send' called with unexpected value for argument 'len'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_accept_new, accept_new, cmock_line, "Function 'relaylib_send' called with unexpected value for argument 'accept_new'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_is_meta, is_meta, cmock_line, "Function 'relaylib_send' called with unexpected value for argument 'is_meta'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_relaylib_send(CMOCK_relaylib_send_CALL_INSTANCE* cmock_call_instance, char* data, int len, int accept_new, int is_meta)
{
  cmock_call_instance->Expected_data = data;
  cmock_call_instance->Expected_len = len;
  cmock_call_instance->Expected_accept_new = accept_new;
  cmock_call_instance->Expected_is_meta = is_meta;
}

void relaylib_send_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_send_CALL_INSTANCE));
  CMOCK_relaylib_send_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_send_CallInstance = CMock_Guts_MemChain(Mock.relaylib_send_CallInstance, cmock_guts_index);
  Mock.relaylib_send_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.relaylib_send_IgnoreBool = (int)1;
}

void relaylib_send_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* data, int len, int accept_new, int is_meta, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_send_CALL_INSTANCE));
  CMOCK_relaylib_send_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_send_CallInstance = CMock_Guts_MemChain(Mock.relaylib_send_CallInstance, cmock_guts_index);
  Mock.relaylib_send_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_send(cmock_call_instance, data, len, accept_new, is_meta);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(error_code));
}

void relaylib_send_StubWithCallback(CMOCK_relaylib_send_CALLBACK Callback)
{
  Mock.relaylib_send_CallbackFunctionPointer = Callback;
}

void relaylib_stop(RIP_MANAGER_INFO* rmi)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_stop_CallInstance);
  Mock.relaylib_stop_CallInstance = CMock_Guts_MemNext(Mock.relaylib_stop_CallInstance);
  if (Mock.relaylib_stop_IgnoreBool)
  {
    return;
  }
  if (Mock.relaylib_stop_CallbackFunctionPointer != NULL)
  {
    Mock.relaylib_stop_CallbackFunctionPointer(rmi, Mock.relaylib_stop_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_stop' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'relaylib_stop' called with unexpected value for argument 'rmi'.");
  }
}

void CMockExpectParameters_relaylib_stop(CMOCK_relaylib_stop_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi)
{
  cmock_call_instance->Expected_rmi = rmi;
}

void relaylib_stop_CMockIgnore(void)
{
  Mock.relaylib_stop_IgnoreBool = (int)1;
}

void relaylib_stop_CMockExpect(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_stop_CALL_INSTANCE));
  CMOCK_relaylib_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_stop_CallInstance = CMock_Guts_MemChain(Mock.relaylib_stop_CallInstance, cmock_guts_index);
  Mock.relaylib_stop_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_stop(cmock_call_instance, rmi);
}

void relaylib_stop_StubWithCallback(CMOCK_relaylib_stop_CALLBACK Callback)
{
  Mock.relaylib_stop_CallbackFunctionPointer = Callback;
}

BOOL relaylib_isrunning(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_isrunning_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_isrunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_isrunning_CallInstance);
  Mock.relaylib_isrunning_CallInstance = CMock_Guts_MemNext(Mock.relaylib_isrunning_CallInstance);
  if (Mock.relaylib_isrunning_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.relaylib_isrunning_FinalReturn;
    Mock.relaylib_isrunning_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.relaylib_isrunning_CallbackFunctionPointer != NULL)
  {
    return Mock.relaylib_isrunning_CallbackFunctionPointer(Mock.relaylib_isrunning_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_isrunning' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  return cmock_call_instance->ReturnVal;
}

void relaylib_isrunning_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BOOL cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_isrunning_CALL_INSTANCE));
  CMOCK_relaylib_isrunning_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_isrunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_isrunning_CallInstance = CMock_Guts_MemChain(Mock.relaylib_isrunning_CallInstance, cmock_guts_index);
  Mock.relaylib_isrunning_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.relaylib_isrunning_IgnoreBool = (int)1;
}

void relaylib_isrunning_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BOOL cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_isrunning_CALL_INSTANCE));
  CMOCK_relaylib_isrunning_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_isrunning_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_isrunning_CallInstance = CMock_Guts_MemChain(Mock.relaylib_isrunning_CallInstance, cmock_guts_index);
  Mock.relaylib_isrunning_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void relaylib_isrunning_StubWithCallback(CMOCK_relaylib_isrunning_CALLBACK Callback)
{
  Mock.relaylib_isrunning_CallbackFunctionPointer = Callback;
}

error_code relaylib_send_meta_data(char* track)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_send_meta_data_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_meta_data_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_send_meta_data_CallInstance);
  Mock.relaylib_send_meta_data_CallInstance = CMock_Guts_MemNext(Mock.relaylib_send_meta_data_CallInstance);
  if (Mock.relaylib_send_meta_data_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.relaylib_send_meta_data_FinalReturn;
    memcpy(&Mock.relaylib_send_meta_data_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(error_code));
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.relaylib_send_meta_data_CallbackFunctionPointer != NULL)
  {
    return Mock.relaylib_send_meta_data_CallbackFunctionPointer(track, Mock.relaylib_send_meta_data_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_send_meta_data' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_track, track, cmock_line, "Function 'relaylib_send_meta_data' called with unexpected value for argument 'track'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_relaylib_send_meta_data(CMOCK_relaylib_send_meta_data_CALL_INSTANCE* cmock_call_instance, char* track)
{
  cmock_call_instance->Expected_track = track;
}

void relaylib_send_meta_data_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_send_meta_data_CALL_INSTANCE));
  CMOCK_relaylib_send_meta_data_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_meta_data_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_send_meta_data_CallInstance = CMock_Guts_MemChain(Mock.relaylib_send_meta_data_CallInstance, cmock_guts_index);
  Mock.relaylib_send_meta_data_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.relaylib_send_meta_data_IgnoreBool = (int)1;
}

void relaylib_send_meta_data_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, char* track, error_code cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_send_meta_data_CALL_INSTANCE));
  CMOCK_relaylib_send_meta_data_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_send_meta_data_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_send_meta_data_CallInstance = CMock_Guts_MemChain(Mock.relaylib_send_meta_data_CallInstance, cmock_guts_index);
  Mock.relaylib_send_meta_data_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_send_meta_data(cmock_call_instance, track);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(error_code));
}

void relaylib_send_meta_data_StubWithCallback(CMOCK_relaylib_send_meta_data_CALLBACK Callback)
{
  Mock.relaylib_send_meta_data_CallbackFunctionPointer = Callback;
}

void relaylib_disconnect(RIP_MANAGER_INFO* rmi, RELAY_LIST* prev, RELAY_LIST* ptr)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_relaylib_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.relaylib_disconnect_CallInstance);
  Mock.relaylib_disconnect_CallInstance = CMock_Guts_MemNext(Mock.relaylib_disconnect_CallInstance);
  if (Mock.relaylib_disconnect_IgnoreBool)
  {
    return;
  }
  if (Mock.relaylib_disconnect_CallbackFunctionPointer != NULL)
  {
    Mock.relaylib_disconnect_CallbackFunctionPointer(rmi, prev, ptr, Mock.relaylib_disconnect_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'relaylib_disconnect' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_rmi), (void*)(rmi), sizeof(RIP_MANAGER_INFO), cmock_line, "Function 'relaylib_disconnect' called with unexpected value for argument 'rmi'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_prev), (void*)(prev), sizeof(RELAY_LIST), cmock_line, "Function 'relaylib_disconnect' called with unexpected value for argument 'prev'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ptr), (void*)(ptr), sizeof(RELAY_LIST), cmock_line, "Function 'relaylib_disconnect' called with unexpected value for argument 'ptr'.");
  }
}

void CMockExpectParameters_relaylib_disconnect(CMOCK_relaylib_disconnect_CALL_INSTANCE* cmock_call_instance, RIP_MANAGER_INFO* rmi, RELAY_LIST* prev, RELAY_LIST* ptr)
{
  cmock_call_instance->Expected_rmi = rmi;
  cmock_call_instance->Expected_prev = prev;
  cmock_call_instance->Expected_ptr = ptr;
}

void relaylib_disconnect_CMockIgnore(void)
{
  Mock.relaylib_disconnect_IgnoreBool = (int)1;
}

void relaylib_disconnect_CMockExpect(UNITY_LINE_TYPE cmock_line, RIP_MANAGER_INFO* rmi, RELAY_LIST* prev, RELAY_LIST* ptr)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_relaylib_disconnect_CALL_INSTANCE));
  CMOCK_relaylib_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_relaylib_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.relaylib_disconnect_CallInstance = CMock_Guts_MemChain(Mock.relaylib_disconnect_CallInstance, cmock_guts_index);
  Mock.relaylib_disconnect_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_relaylib_disconnect(cmock_call_instance, rmi, prev, ptr);
}

void relaylib_disconnect_StubWithCallback(CMOCK_relaylib_disconnect_CALLBACK Callback)
{
  Mock.relaylib_disconnect_CallbackFunctionPointer = Callback;
}

